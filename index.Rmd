---
title: "Portfolio Reginald van Putt"
author: "Reginald van Putt"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    orientation: columns
    
date: "2024-02-21"
---
```{r variabels, echo=FALSE}
# Loading in libraries
library(flexdashboard)
library(readr)
library(dendextend)
library(lubridate)
library(ggplot2)
library(tidyverse)
library(tidymodels)
library(spotifyr)
library(compmus)
library(agricolae)
library(ggdendro)
library(heatmaply)

# Set default chunk options for all plots
knitr::opts_chunk$set(fig.width = 5, fig.height = 4)

id <- "3224ef21d8e245689234aa11d3f2e919"
secret <-"f83518a285bd4bdfbfd77bdda440df7e"
Sys.setenv(SPOTIFY_CLIENT_ID = id)
Sys.setenv(SPOTIFY_CLIENT_SECRET = secret)
access_token <- get_spotify_access_token()
```

```{r circshift}
library(tidyverse)
library(spotifyr)
library(compmus)

circshift <- function(v, n) {
  if (n == 0) v else c(tail(v, n), head(v, -n))
}

#      C     C#    D     Eb    E     F     F#    G     Ab    A     Bb    B
major_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    0,    0)
minor_chord <-
  c(   1,    0,    0,    1,    0,    0,    0,    1,    0,    0,    0,    0)
seventh_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    1,    0)

major_key <-
  c(6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88)
minor_key <-
  c(6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17)

chord_templates <-
  tribble(
    ~name, ~template,
    "Gb:7", circshift(seventh_chord, 6),
    "Gb:maj", circshift(major_chord, 6),
    "Bb:min", circshift(minor_chord, 10),
    "Db:maj", circshift(major_chord, 1),
    "F:min", circshift(minor_chord, 5),
    "Ab:7", circshift(seventh_chord, 8),
    "Ab:maj", circshift(major_chord, 8),
    "C:min", circshift(minor_chord, 0),
    "Eb:7", circshift(seventh_chord, 3),
    "Eb:maj", circshift(major_chord, 3),
    "G:min", circshift(minor_chord, 7),
    "Bb:7", circshift(seventh_chord, 10),
    "Bb:maj", circshift(major_chord, 10),
    "D:min", circshift(minor_chord, 2),
    "F:7", circshift(seventh_chord, 5),
    "F:maj", circshift(major_chord, 5),
    "A:min", circshift(minor_chord, 9),
    "C:7", circshift(seventh_chord, 0),
    "C:maj", circshift(major_chord, 0),
    "E:min", circshift(minor_chord, 4),
    "G:7", circshift(seventh_chord, 7),
    "G:maj", circshift(major_chord, 7),
    "B:min", circshift(minor_chord, 11),
    "D:7", circshift(seventh_chord, 2),
    "D:maj", circshift(major_chord, 2),
    "F#:min", circshift(minor_chord, 6),
    "A:7", circshift(seventh_chord, 9),
    "A:maj", circshift(major_chord, 9),
    "C#:min", circshift(minor_chord, 1),
    "E:7", circshift(seventh_chord, 4),
    "E:maj", circshift(major_chord, 4),
    "G#:min", circshift(minor_chord, 8),
    "B:7", circshift(seventh_chord, 11),
    "B:maj", circshift(major_chord, 11),
    "D#:min", circshift(minor_chord, 3)
  )

key_templates <-
  tribble(
    ~name, ~template,
    "Gb:maj", circshift(major_key, 6),
    "Bb:min", circshift(minor_key, 10),
    "Db:maj", circshift(major_key, 1),
    "F:min", circshift(minor_key, 5),
    "Ab:maj", circshift(major_key, 8),
    "C:min", circshift(minor_key, 0),
    "Eb:maj", circshift(major_key, 3),
    "G:min", circshift(minor_key, 7),
    "Bb:maj", circshift(major_key, 10),
    "D:min", circshift(minor_key, 2),
    "F:maj", circshift(major_key, 5),
    "A:min", circshift(minor_key, 9),
    "C:maj", circshift(major_key, 0),
    "E:min", circshift(minor_key, 4),
    "G:maj", circshift(major_key, 7),
    "B:min", circshift(minor_key, 11),
    "D:maj", circshift(major_key, 2),
    "F#:min", circshift(minor_key, 6),
    "A:maj", circshift(major_key, 9),
    "C#:min", circshift(minor_key, 1),
    "E:maj", circshift(major_key, 4),
    "G#:min", circshift(minor_key, 8),
    "B:maj", circshift(major_key, 11),
    "D#:min", circshift(minor_key, 3)
  )


```

```{r loading_playlists, echo=FALSE}
#science
pb_features = get_playlist_audio_features("","1dDP0J8kZlyQJ1kw2heuqN") #1
pb_features_2 = get_playlist_audio_features("","5f67hG4cT4vuCbpp2ZJSAC") #2
bs_features = get_playlist_audio_features("","55RF4Rd8rbn4cYKS5fCn2r") #1
bs_features_2 = get_playlist_audio_features("","4gud4X0Q6RV9M2tioEMOvy") #2
medicine_features = get_playlist_audio_features("","5BTPZghhEMr9e6mfGHmv0A") #1
biology_features = get_playlist_audio_features("","2ZyiCXQK1GUCfp33TSOQO6") #1
ai_features = get_playlist_audio_features("","61qvD51DpYY12Sh0GDsmwl") #1
ai_features_2 = get_playlist_audio_features("","2ESdPa7Lsat6szfqcb8TqG") #2
ai_features_3 = get_playlist_audio_features("","05BS3494bYcIokpptZbpgg") #3

#technical uni
ce_features = get_playlist_audio_features("","0ZgkUJVQ5FjavIZBp7zDK7") #1
id_features = get_playlist_audio_features("","01HKzQnzQ5XLn5OefshdIx") #1
me_features = get_playlist_audio_features("","1kZBSsmIMAUocJgM6Dm32F") #1
se_features = get_playlist_audio_features("","4jD1Ua5umx6PTvqhPxD6Qg") #1
me_features_2 = get_playlist_audio_features("","2yIbLUOhrdCSnYJJqUIC9l") #2

#social sciences
cs_features = get_playlist_audio_features("","1xAbFlGMk4NeTcHlXVxNIT") #1
psychology_features = get_playlist_audio_features("","7lN3BZW8AhOzpLpyPY5FqA") #1
sw_features = get_playlist_audio_features("","7FfkG5ZbE9IhpJNOHBqRZM") #1
cs_mmd_features = get_playlist_audio_features("","7bK5sUCOoSwURe0qHZSfLM") #1
education_features = get_playlist_audio_features("","6lUVL6Tq0RRUPqSdjP3ChC") #1
soc_features = get_playlist_audio_features("","0e5Xnkt5CG4DhnpvUtlsAy") #1

#humanities
musicology_features = get_playlist_audio_features("","2GNR2qLtjanP6VtxKmIERI") #1
musicology_features_2 = get_playlist_audio_features("","2Cmef8ivNr7eIby2eYDInj") #2
art_features = get_playlist_audio_features("","4eRCLFaLG2PcT3RcJpEVA5") #1


```

```{r faculty_dividing, echo=FALSE}
sci = "Faculty of Science"
hum = "Faculty of Humanities"
tech = "Technical University studies"
soc = "Social and Behavior studies"
med = "Faculty of Medicine"

final_data <-
  bind_rows(
    #science
    pb_features |> mutate(bachelor = "Psychobiology", faculty = sci),
    pb_features_2 |> mutate(bachelor = "Psychobiology", faculty = sci),
    bs_features |> mutate(bachelor = "Biomedical science", faculty = sci),
    bs_features_2 |> mutate(bachelor = "Biomedical science", faculty = sci),
    biology_features |> mutate(bachelor = "Biology", faculty = sci),
    ai_features |> mutate(bachelor = "Artifical intelligence", faculty = sci),
    ai_features_2 |> mutate(bachelor = "Artifical intelligence", faculty = sci),
    ai_features_3 |> mutate(bachelor = "Artifical intelligence", faculty = sci), #music = FALSE
    medicine_features |> mutate(bachelor = "Medicine", faculty = sci),
    
    #technical uni
    ce_features |> mutate(bachelor = "Civil engineering", faculty = tech),
    id_features |> mutate(bachelor = "Industrial engineering", faculty = tech),
    me_features |> mutate(bachelor = "Mechanical engineering", faculty = tech),
    se_features |> mutate(bachelor = "Software engineering", faculty = tech), #music = FALSE
    me_features_2 |> mutate(bachelor = "Mechanical engineering", faculty = tech), #music = FALSE
    
    #social sciences
    cs_features |> mutate(bachelor = "Communication science", faculty = soc),
    psychology_features |> mutate(bachelor = "Psychology", faculty = soc),
    sw_features |> mutate(bachelor = "Social works", faculty = soc),
    cs_mmd_features |> mutate(bachelor = "Communication & MM design", faculty = soc), #music = TRUE
    education_features |> mutate(bachelor = "Education in primary school", faculty = soc), #music = FALSE
    soc_features |> mutate(bachelor = "Sociology", faculty = soc), #music = FALSE
    
    
    #humanities
    musicology_features |> mutate(bachelor = "Musicology", faculty = hum), #music = TRUE
    musicology_features_2 |> mutate(bachelor = "Musicology", faculty = hum), #music = TRUE
    art_features |> mutate(bachelor = "Art and Music", faculty = hum)

    
  )
```

Introduction
=======================================================================

Row  {.tabset}
-----------------------------------------------------------------------
Welcome to my portfolio,

I'm Reginald van Putt and this is my portfolio for the course Computational Musicology (UvA). In this portfolio I will investigate a corpus that I have created with help of my peers and friends. The corpus exists off the top 5 songs of people from all kinds of bachelors. With this corpus I'm trying to investigate whether or not there is a significant difference in study directions in terms of music taste. Specifically looking at the valence, energy and loudness. 

*Why?*

The reason why I wanted to investigate this is because I quite often ask people about their music taste and I have done a few courses from different faculties and it seemed to me that different faculties (i.e. FNWI vs AI) have quite different tastes in music. So I that's why I wanted to analyse more data and see if there is a significant difference. I initially wanted to also include genre in the analysis. But this turned out to be a lot more complicated then I thought initially, hence i dropped this part of the analysis. 

The graph underneath this shows all the data I have incorporated in my corpus. On the x-axis you can see the valence and on the y-axis the energy of the songs, the size of the dots are correlated to the loudness of the songs. The songs plotted are the top 5 songs of many peers and friends, the colors are divided based on the faculty and the graphs are also divided based on faculty/direction of the bachelors of the participants.

```{r make_plot}
final_data |>                    # Start with awards.
  mutate(
    mode = ifelse(mode == 0, "Minor", "Major")
  ) |>
  ggplot(                     # Set up the plot.
    aes(
      x = valence,
      y = energy,
      size = loudness,
      colour = faculty
    )
  ) +
  geom_point() +              # Scatter plot.
  geom_rug(linewidth = 0.1) + # Add 'fringes' to show data distribution.
  geom_text(                  # Add text labels from above.
    aes(
      x = valence,
      y = energy,
      label = label
    ),
    data = 
      tibble(
        label = c("", ""), #top and bottom labels
        category = c("Edisons", "Grammys"),
        valence = c(0.104, 0.0339),
        energy = c(0.992, 0.00166)
      ),
    colour = "black",         # Override colour (not mode here).
    size = 3,                 # Override size (not loudness here).
    hjust = "left",           # Align left side of label with the point.
    vjust = "center",         # Align vertical center of label with the point.
    nudge_x = 0.02            # Nudge the label slightly right.
  ) +
  facet_wrap(~ faculty) +    # Separate charts per playlist.
  scale_x_continuous(         # Fine-tune the x axis.
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),   # Use grid-lines for quadrants only.
    minor_breaks = NULL       # Remove 'minor' grid-lines.
  ) +
  scale_y_continuous(         # Fine-tune the y axis in the same way.
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),
    minor_breaks = NULL
  ) +
  scale_colour_brewer(        # Use the Color Brewer to choose a palette.
    type = "qual",            # Qualitative set.
    palette = "Paired"        # Name of the palette is 'Paired'.
  ) +
  scale_size_continuous(      # Fine-tune the sizes of each point.
    trans = "exp",            # Use an exp transformation to emphasise loud.
    guide = "none"            # Remove the legend for size.
  ) +
  theme_light() +             # Use a simpler theme.
  labs(                       # Make the titles nice.
    x = "Valence",
    y = "Energy",
    title = "Top 5 songs for different bachelors",
    #colour = "Bachelor"
  )
```


Main corpus visualization
=======================================================================

Row  {.tabset}
-----------------------------------------------------------------------

### Faculty of Humanities
```{r}
final_data_humanities <- filter(final_data, faculty == "Faculty of Humanities")

final_data_humanities |>                    # Start with awards.
  mutate(
    mode = ifelse(mode == 0, "Minor", "Major")
  ) |>
  ggplot(                     # Set up the plot.
    aes(
      x = valence,
      y = energy,
      size = loudness,
      colour = bachelor
    )
  ) +
  geom_point() +              # Scatter plot.
  geom_rug(linewidth = 0.1) + # Add 'fringes' to show data distribution.
  geom_text(                  # Add text labels from above.
    aes(
      x = valence,
      y = energy,
      label = label
    ),
    data = 
      tibble(
        label = c("", ""), #top and bottom labels
        category = c("Edisons", "Grammys"),
        valence = c(0.104, 0.0339),
        energy = c(0.992, 0.00166)
      ),
    colour = "black",         # Override colour (not mode here).
    size = 3,                 # Override size (not loudness here).
    hjust = "left",           # Align left side of label with the point.
    vjust = "center",         # Align vertical center of label with the point.
    nudge_x = 0.02            # Nudge the label slightly right.
  ) +
  # facet_wrap(~ faculty) +    # Separate charts per playlist.
  # scale_x_continuous(         # Fine-tune the x axis.
  #   limits = c(0, 1),
  #   breaks = c(0, 0.50, 1),   # Use grid-lines for quadrants only.
  #   minor_breaks = NULL       # Remove 'minor' grid-lines.
  # ) +
  scale_y_continuous(         # Fine-tune the y axis in the same way.
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),
    minor_breaks = NULL
  ) +
  scale_colour_brewer(        # Use the Color Brewer to choose a palette.
    type = "qual",            # Qualitative set.
    palette = "Paired"        # Name of the palette is 'Paired'.
  ) +
  scale_size_continuous(      # Fine-tune the sizes of each point.
    trans = "exp",            # Use an exp transformation to emphasise loud.
    guide = "none"            # Remove the legend for size.
  ) +
  theme_light() +             # Use a simpler theme.
  labs(                       # Make the titles nice.
    x = "Valence",
    y = "Energy",
    title = "Top 5 songs for different bachelors",
    colour = "Bachelor"
  )

```


### Faculty of Science
```{r}
final_data_science <- filter(final_data, faculty == "Faculty of Science")

final_data_science |>                    # Start with awards.
  mutate(
    mode = ifelse(mode == 0, "Minor", "Major")
  ) |>
  ggplot(                     # Set up the plot.
    aes(
      x = valence,
      y = energy,
      size = loudness,
      colour = bachelor
    )
  ) +
  geom_point() +              # Scatter plot.
  geom_rug(linewidth = 0.1) + # Add 'fringes' to show data distribution.
  geom_text(                  # Add text labels from above.
    aes(
      x = valence,
      y = energy,
      label = label
    ),
    data = 
      tibble(
        label = c("", ""), #top and bottom labels
        category = c("Edisons", "Grammys"),
        valence = c(0.104, 0.0339),
        energy = c(0.992, 0.00166)
      ),
    colour = "black",         # Override colour (not mode here).
    size = 3,                 # Override size (not loudness here).
    hjust = "left",           # Align left side of label with the point.
    vjust = "center",         # Align vertical center of label with the point.
    nudge_x = 0.02            # Nudge the label slightly right.
  ) +
  # facet_wrap(~ faculty) +    # Separate charts per playlist.
  # scale_x_continuous(         # Fine-tune the x axis.
  #   limits = c(0, 1),
  #   breaks = c(0, 0.50, 1),   # Use grid-lines for quadrants only.
  #   minor_breaks = NULL       # Remove 'minor' grid-lines.
  # ) +
  scale_y_continuous(         # Fine-tune the y axis in the same way.
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),
    minor_breaks = NULL
  ) +
  scale_colour_brewer(        # Use the Color Brewer to choose a palette.
    type = "qual",            # Qualitative set.
    palette = "Paired"        # Name of the palette is 'Paired'.
  ) +
  scale_size_continuous(      # Fine-tune the sizes of each point.
    trans = "exp",            # Use an exp transformation to emphasise loud.
    guide = "none"            # Remove the legend for size.
  ) +
  theme_light() +             # Use a simpler theme.
  labs(                       # Make the titles nice.
    x = "Valence",
    y = "Energy",
    title = "Top 5 songs for different bachelors",
    colour = "Bachelor"
  )
```


### Social and Behavior Studies
```{r}
final_data_sb <- filter(final_data, faculty == "Social and Behavior studies")

final_data_sb |>                    # Start with awards.
  mutate(
    mode = ifelse(mode == 0, "Minor", "Major")
  ) |>
  ggplot(                     # Set up the plot.
    aes(
      x = valence,
      y = energy,
      size = loudness,
      colour = bachelor
    )
  ) +
  geom_point() +              # Scatter plot.
  geom_rug(linewidth = 0.1) + # Add 'fringes' to show data distribution.
  geom_text(                  # Add text labels from above.
    aes(
      x = valence,
      y = energy,
      label = label
    ),
    data = 
      tibble(
        label = c("", ""), #top and bottom labels
        category = c("Edisons", "Grammys"),
        valence = c(0.104, 0.0339),
        energy = c(0.992, 0.00166)
      ),
    colour = "black",         # Override colour (not mode here).
    size = 3,                 # Override size (not loudness here).
    hjust = "left",           # Align left side of label with the point.
    vjust = "center",         # Align vertical center of label with the point.
    nudge_x = 0.02            # Nudge the label slightly right.
  ) +
  # facet_wrap(~ faculty) +    # Separate charts per playlist.
  # scale_x_continuous(         # Fine-tune the x axis.
  #   limits = c(0, 1),
  #   breaks = c(0, 0.50, 1),   # Use grid-lines for quadrants only.
  #   minor_breaks = NULL       # Remove 'minor' grid-lines.
  # ) +
  scale_y_continuous(         # Fine-tune the y axis in the same way.
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),
    minor_breaks = NULL
  ) +
  scale_colour_brewer(        # Use the Color Brewer to choose a palette.
    type = "qual",            # Qualitative set.
    palette = "Paired"        # Name of the palette is 'Paired'.
  ) +
  scale_size_continuous(      # Fine-tune the sizes of each point.
    trans = "exp",            # Use an exp transformation to emphasise loud.
    guide = "none"            # Remove the legend for size.
  ) +
  theme_light() +             # Use a simpler theme.
  labs(                       # Make the titles nice.
    x = "Valence",
    y = "Energy",
    title = "Top 5 songs for different bachelors",
    colour = "Bachelor"
  )
```


### Technical University Studies
```{r}
final_data_tu <- filter(final_data, faculty == "Technical University studies")

final_data_tu |>                    # Start with awards.
  mutate(
    mode = ifelse(mode == 0, "Minor", "Major")
  ) |>
  ggplot(                     # Set up the plot.
    aes(
      x = valence,
      y = energy,
      size = loudness,
      colour = bachelor
    )
  ) +
  geom_point() +              # Scatter plot.
  geom_rug(linewidth = 0.1) + # Add 'fringes' to show data distribution.
  geom_text(                  # Add text labels from above.
    aes(
      x = valence,
      y = energy,
      label = label
    ),
    data = 
      tibble(
        label = c("", ""), #top and bottom labels
        category = c("Edisons", "Grammys"),
        valence = c(0.104, 0.0339),
        energy = c(0.992, 0.00166)
      ),
    colour = "black",         # Override colour (not mode here).
    size = 3,                 # Override size (not loudness here).
    hjust = "left",           # Align left side of label with the point.
    vjust = "center",         # Align vertical center of label with the point.
    nudge_x = 0.02            # Nudge the label slightly right.
  ) +
  # facet_wrap(~ faculty) +    # Separate charts per playlist.
  # scale_x_continuous(         # Fine-tune the x axis.
  #   limits = c(0, 1),
  #   breaks = c(0, 0.50, 1),   # Use grid-lines for quadrants only.
  #   minor_breaks = NULL       # Remove 'minor' grid-lines.
  # ) +
  scale_y_continuous(         # Fine-tune the y axis in the same way.
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),
    minor_breaks = NULL
  ) +
  scale_colour_brewer(        # Use the Color Brewer to choose a palette.
    type = "qual",            # Qualitative set.
    palette = "Paired"        # Name of the palette is 'Paired'.
  ) +
  scale_size_continuous(      # Fine-tune the sizes of each point.
    trans = "exp",            # Use an exp transformation to emphasise loud.
    guide = "none"            # Remove the legend for size.
  ) +
  theme_light() +             # Use a simpler theme.
  labs(                       # Make the titles nice.
    x = "Valence",
    y = "Energy",
    title = "Top 5 songs for different bachelors",
    colour = "Bachelor"
  )
```


### Explanation of the graphs

Unfortunatly do to some glitches I was not able to place the text next to the graphs, so here are all the details and explanations of the graphs:

*Faculty of Humanities:*

This graphs shows the valence on the x-axis, energy on the y-axis, the color is correlated to the bachelor type and the size of the dots are correlated to the loudness. A thing to note is that this graph has a lot less bachelors then the other faculty graphs. However each bachelor has more then 1 data set/participant, meaning that this is more then just 2 data sets. This data set is quite similar to most data sets that have this format. You often see a lot of songs in the upper half and left side of the graph. And almost nothing in the bottom right. There is 1 song that does present itself in this corner of the graph, but I kept it inside the data because I do not think I should remove outliers like this in the representations or calculations. 


*Faculty of Science:*

This graphs shows the valence on the x-axis, energy on the y-axis, the color is correlated to the bachelor type and the size of the dots are correlated to the loudness. This data set is quite similar to most data sets that have this format. You often see a lot of songs in the upper half and left side of the graph. And almost nothing in the bottom right, however I do see a low amount of songs in the bottom left corner as well, which might mean that the average energy of this faculty lies higher then average datasets due to the lack of songs in the bottom half. 


*Social and Behavior Studies:*

This graphs shows the valence on the x-axis, energy on the y-axis, the color is correlated to the bachelor type and the size of the dots are correlated to the loudness. This data set is quite similar to most data sets that have this format. You often see a lot of songs in the upper half and left side of the graph. And almost nothing in the bottom right. This is quite similair to this data set and therefor the data seems quite average. It looks like this data set has a higher average loudness then other faculties. Which might indicate that the energy is also slightly higher, because loudness has a (partial) correlation to energy. 


*Technical University Studies:*

This graphs shows the valence on the x-axis, energy on the y-axis, the color is correlated to the bachelor type and the size of the dots are correlated to the loudness. This data set is quite similar to most data sets that have this format. You often see a lot of songs in the upper half and left side of the graph. And almost nothing in the bottom right. This graph however shows little datapoints in the bottom left as well, suggesting a higher average energy level then average datasets and some of the other data sets in this corpus.

Visualizations
=======================================================================

Row  {.tabset}
-----------------------------------------------------------------------

### Chromagram

```{r chromagram}
#chromagram 1
outlier <-
  get_tidy_audio_analysis("1oDCK7PW72XEZ1pE5rh87A") |>
  select(segments) |>
  unnest(segments) |>
  select(start, duration, pitches)

outlier_duration = duration

outlier |>
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) |>
  compmus_gather_chroma() |> 
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = pitch_class,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  theme_minimal() +
  scale_fill_viridis_c() +
  ggtitle("The outlier") +
  theme(plot.caption = element_text(hjust = 0, margin = margin(t = 10))) +
  labs(caption = "This is the chromagram of a song that is an outlier, meaning it is far away from all other songs of the corpus in terms of valence and energy. ") 
  #theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  #theme(plot.background = element_rect(fill = "white", colour = "black")) +
  #theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))

#chromagram 2
normal_song <-
  get_tidy_audio_analysis("6fl6EkGqKlpZECkys1iDsq") |>
  select(segments) |>
  unnest(segments) |>
  select(start, duration, pitches)

normal_song |>
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) |>
  compmus_gather_chroma() |> 
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = pitch_class,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  theme_minimal() +
  scale_fill_viridis_c() +
  ggtitle("'Average song'") +
  theme(plot.caption = element_text(hjust = 0, margin = margin(t = 10))) +
    labs(caption = "This is the chromagram of a song that is quite average, meaning it is pretty much in the middle off all other songs of the corpus in terms of valence and energy. ") 

  #theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  #theme(plot.background = element_rect(fill = "white", colour = "black")) +
  #theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
```

***
The reason that the left song has lower energy and valence might be due to the lower frequency of notes, it looks like the amount of notes is quite a bit lower then in the right song / average song. Secondly the valence might be lower because of the fact that the outlier song is mostly minor while the average song is mostly major (according to spotify). Which you might be able to see looking at the chords played throughout the song.


### Key analysis

#### Low
```{r key analysis}
#Lowest valence song

low_valence <-
  get_tidy_audio_analysis("0oL9JFFf33CZP47Kg30U7e") |>
  compmus_align(sections, segments) |>
  select(sections) |>
  unnest(sections) |>
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )

low_valence |> 
  compmus_match_pitch_template(
    key_templates,         # Change to chord_templates if desired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) |>
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "") +
  ggtitle("Lowest valence song") +
  theme(plot.caption = element_text(hjust = 0, margin = margin(t = 10))) +
  labs(caption = "This is the song with the lowest valence of the group 'Faculty of Science'.\n It is shown here in the form of a keygram")

```

#### High
```{r}

#Highest valence song

high_valence <-
  get_tidy_audio_analysis("3gY6tiCNsuVi6s8kPV6aQg") |>
  compmus_align(sections, segments) |>
  select(sections) |>
  unnest(sections) |>
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )

high_valence |> 
  compmus_match_pitch_template(
    key_templates,         # Change to chord_templates if desired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) |>
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "") +
  ggtitle("Highest valence song") +
  theme(plot.caption = element_text(hjust = 0, margin = margin(t = 10))) +
  labs(caption = "This is the song with the higest valence of the group 'Faculty of Science'.\n It is shown here in the form of a keygram")

```

#### Random
```{r average}
random_average <-
  get_tidy_audio_analysis("6SG8lh7fWQ2bahP5WBYePn") |>
  compmus_align(sections, segments) |>
  select(sections) |>
  unnest(sections) |>
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )

random_average |> 
  compmus_match_pitch_template(
    key_templates,         # Change to chord_templates if desired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) |>
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "") +
  ggtitle("Random song") +
  theme(plot.caption = element_text(hjust = 0, margin = margin(t = 10))) +
  labs(caption = "This is a random song of the group 'Faculty of Science'.\n It is shown here in the form of a keygram")

```
 
***
The keygrams are quit interesting to compare. The lowest valence song shows a vertical band between 150 and 200 seconds. Meaning that there are more keys being used in that time period compared to the rest. Throughout the song the keys that are used the majority of the time are kind of the same. but the quantity/certainty of it differs a bit.
For the highest valence song it's quite different. there are not a lot of keys that are used but the keys that are used are really stable though the whole song. For the random song there is a lot of uniformity throught the song, but some slight differences such as in the intro and 2 (probably) bridges of sort.

### Chord analysis

#### Low
```{r chord_analysis, echo=FALSE}
#Lowest valence song
# Chord analysis tab
low_valence <-
  get_tidy_audio_analysis("0oL9JFFf33CZP47Kg30U7e") |>
  compmus_align(sections, segments) |>
  select(sections) |>
  unnest(sections) |>
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )

low_valence |> 
  compmus_match_pitch_template(
    chord_templates,         # Change to chord_templates if desired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) |>
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "") +
  ggtitle("Lowest valence song") +
  theme(plot.caption = element_text(hjust = 0, margin = margin(t = 10))) +
  labs(caption = "This is the song with the lowest valence of the group 'Faculty of Science'.\n It is shown here in the form of a chordogram.")

```

#### High
```{r}

#Highest valence song

high_valence <-
  get_tidy_audio_analysis("3gY6tiCNsuVi6s8kPV6aQg") |>
  compmus_align(sections, segments) |>
  select(sections) |>
  unnest(sections) |>
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )

high_valence |> 
  compmus_match_pitch_template(
    chord_templates,         # Change to chord_templates if desired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) |>
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "") +
  ggtitle("Highest valence song") +
  theme(plot.caption = element_text(hjust = 0, margin = margin(t = 10))) +
  labs(caption = "This is the song with the higest valence of the group 'Faculty of Science'.\n It is shown here in the form of a chordogram.")

```

#### Random
```{r}
random_average <-
  get_tidy_audio_analysis("6SG8lh7fWQ2bahP5WBYePn") |>
  compmus_align(sections, segments) |>
  select(sections) |>
  unnest(sections) |>
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )

random_average |> 
  compmus_match_pitch_template(
    chord_templates,         # Change to chord_templates if desired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) |>
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "") +
  ggtitle("Random song") +
  theme(plot.caption = element_text(hjust = 0, margin = margin(t = 10))) +
  labs(caption = "This is a random song of the group 'Faculty of Science'.\n It is shown here in the form of a chordogram.")

```


***

There seem to be a very big overlap between chords used in all three songs. Almost (if not all) chords seem to be the same (if looking at the blue-est parts of the chordgram). This surprised me since the valence of these songs is quite different and not all songs are of the same genre (so not just generic pop songs). 


Tempo analysis
=======================================================================

Row  {.tabset}
-----------------------------------------------------------------------
### Novelty graph of loudness

#### Low valence
```{r low_tempi}

#filtered_data <- filter(final_data, faculty == "Faculty of Science")

low_valence_tempo <-
  get_tidy_audio_analysis("0oL9JFFf33CZP47Kg30U7e") |> 
  select(segments) |>
  unnest(segments)

low_valence_tempo |>
  mutate(loudness_max_time = start + loudness_max_time) |>
  arrange(loudness_max_time) |>
  mutate(delta_loudness = loudness_max - lag(loudness_max)) |>
  ggplot(aes(x = loudness_max_time, y = pmax(0, delta_loudness))) +
  geom_line() +
  xlim(0, 180) +
  theme_minimal() +
  labs(x = "Time (s)", y = "Novelty")

```

#### High valence
```{r high_tempi}

#filtered_data <- filter(final_data, faculty == "Faculty of Science")

high_valence_tempo <-
  get_tidy_audio_analysis("3gY6tiCNsuVi6s8kPV6aQg") |> 
  select(segments) |>
  unnest(segments)

high_valence_tempo |>
  mutate(loudness_max_time = start + loudness_max_time) |>
  arrange(loudness_max_time) |>
  mutate(delta_loudness = loudness_max - lag(loudness_max)) |>
  ggplot(aes(x = loudness_max_time, y = pmax(0, delta_loudness))) +
  geom_line() +
  xlim(0, 180) +
  theme_minimal() +
  labs(x = "Time (s)", y = "Novelty")

```

***
Here you see two songs of the corpus, more specifically two songs out of the Faculty of Science category. The first graph is a novelty graph of loudness of the song with the lowest valence and the second graph is a novelty graph of loudness of the song with the highest valence (both according to spotify's api). A thing to notice is that the high valence songs is quite a bit more averaged novelty of loudness (quite even over the song) while the low valence song has a lot of really high peaks. The large difference in peaks and lows of the low valence song is because of the fact that this song has a lot of loudness differences to highlight the emotions in the song, which are mostly created by the large portions of no vocals and the sudden piano volume increases. I think that this also explains the low valence. The high valence song is a rap song, the song starts with some adlibs and music and bird sounds, which are extra loud compared to instrumentals in the rest of the song. This explains the peak in loudness at the start. On average, rap songs have pretty even loudness across the songs so that explains the rest of the graph.

Something to note is that both graphs only show 180 seconds of the song, this is due to calculation times and because it would get to messy if the full song got showed.

The 2 songs used are: Rosebud||Man-Made-Sunshine(low valence) and Nas is like||Nas (high valence)

### Tempogram

#### Low valence
```{r low_tempogram}
low_valence_tempogram <- get_tidy_audio_analysis("0oL9JFFf33CZP47Kg30U7e")
low_valence_tempogram |> 
  tempogram(window_size = 8, hop_size = 1, cyclic = TRUE) |>
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  scale_fill_viridis_c(guide = "none") +
  labs(x = "Time (s)", y = "Tempo (BPM)") +
  theme_classic()

```

#### High valence
```{r high_tempogram}
high_valence_tempogram <- get_tidy_audio_analysis("3gY6tiCNsuVi6s8kPV6aQg")
high_valence_tempogram |> 
  tempogram(window_size = 8, hop_size = 1, cyclic = TRUE) |>
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  scale_fill_viridis_c(guide = "none") +
  labs(x = "Time (s)", y = "Tempo (BPM)") +
  theme_classic()

```

***
The tempograms shown above both have the time of the song on the x-axis and the tempo in beats per minute (BPM) in the y-axis. The color shows in a gradient the likeliness of matching of different tempo's (yellow being a higher chance then blue). The first graph shows the same low valence song as in the novelty graph of loudness. This song has a pretty clear line around 85 BPM but also a lot of clutter all over the graph. This is most likely because of the lack of percussion and non consistent singing, making it hard for the algorithm to figure out the tempo. 

The high valence song (also the same as in the novelty graph of loudness) has a pretty clear line around the 95 BPM, and almost no clutter compared to the low valence song. Which is probably because of the same general beat used throughout the whole song. The lines are slightly more blurry at the start and end because the intro and outro are a bit different.

Dendrogram
=======================================================================

Row  {.tabset}
-----------------------------------------------------------------------
### Dendrogram of the Faculty of Science dataset

```{r}
final_data_filtered <- final_data[-12, ]
final_data_filtered <- filter(final_data_filtered, faculty == "Faculty of Science")

halloween <-
  #get_playlist_audio_features("bnfcollection", "1vsoLSK3ArkpaIHmUaF02C") |>
  final_data_filtered |>
  add_audio_analysis() |>
  mutate(
    segments = map2(segments, key, compmus_c_transpose),
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      ),
    timbre =
      map(
        segments,
        compmus_summarise, timbre,
        method = "mean"
      )
  ) |>
  mutate(pitches = map(pitches, compmus_normalise, "clr")) |>
  mutate_at(vars(pitches, timbre), map, bind_rows) |>
  unnest(cols = c(pitches, timbre))

halloween_juice <-
  recipe(
    track.name ~
      danceability +
      energy +
      loudness +
      speechiness +
      acousticness +
      instrumentalness +
      liveness +
      valence +
      tempo +
      duration +
      C + `C#|Db` + D + `D#|Eb` +
      E + `F` + `F#|Gb` + G +
      `G#|Ab` + A + `A#|Bb` + B +
      c01 + c02 + c03 + c04 + c05 + c06 +
      c07 + c08 + c09 + c10 + c11 + c12,
    data = halloween
  ) |>
  step_center(all_predictors()) |>
  step_scale(all_predictors()) |> 
  # step_range(all_predictors()) |> 
  prep(halloween |> mutate(track.name = str_trunc(track.name, 20))) |>
  juice() |>
  column_to_rownames("track.name")


# Define colors for each faculty category
color_mapping <- c("Faculty of Science" = "blue", 
                   "Faculty of Humanities" = "green", 
                   "Technical University studies" = "red", 
                   "Social and Behavior studies" = "purple")

# Create a color vector based on the "faculty" variable
color_vector <- factor(final_data_filtered$faculty, levels = names(color_mapping))


#color_vector <- color_mapping[final_data_filtered$faculty]

halloween_dist <- dist(halloween_juice, method = "euclidean")

# # Plot the dendrogram with colors
# halloween_dendro <- halloween_dist |> 
#   hclust(method = "complete") |> # Try single, average, and complete.
#   dendro_data()


#testing
colors <- rainbow(length(unique(color_mapping)))

halloween_dendro <- halloween_dist |> 
  hclust(method = "complete") |> # Try single, average, and complete.
  as.dendrogram()  # Convert to dendrogram object

ordered_colors <- color_vector[order.dendrogram(halloween_dendro)]
dend_colored <- color_branches(halloween_dendro, k = length(unique(color_mapping)), col = colors[ordered_colors])
plot(dend_colored) + theme(axis.text.x = element_text(size = 8))  # Adjust font size of x-axis labels


# # Create a data frame for plotting with colors
# plot_data <- data.frame(halloween_dendro$segments, color = rep(color_vector, each = nrow(halloween_dendro$segments)))
# 
# # Plot the dendrogram with colors and song titles on x-axis
# ggplot(plot_data) +
#   geom_segment(aes(x = x, y = y, xend = xend, yend = yend, color = color), size = 1.5) +
#   scale_color_manual(values = color_mapping) +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

```

### Explanation of the graph

When looking at this dendrogram I immediately notice that a lot of clusters consist of 5 songs. Looking at the fact that everyone that provided data gave me 5 songs, this would make a lot of sense. Mainly because a lot of people have matching genres or even performers in their top 5 songs. I originally wanted to include the other faculties as well and divide them in colors, this however was a challenge that I could not overcome, I have spend approximately 10 hours on it and nothing seemed to work. So I settled for this representation.

Statistical analysis
=======================================================================

Row  {.tabset}
-----------------------------------------------------------------------

### Post hoc results energy

```{r statistcal_analysis_energy}

#final_data %>%
  #group_by(faculty) %>%
  #select(valence, energy, faculty, bachelor) %>%
  #summarize(mean_valence = mean(valence), mean_energy = mean(energy), sd_valence = sd(valence), sd_energy = sd(energy))

anova_result_1 <- aov(energy ~ faculty, data = final_data)

#summary(anova_result_1)
#summary(anova_result_2)

tukey_result_1 <- HSD.test(anova_result_1, "faculty", group = TRUE) #energy


# Access the "statistics" component
statistics <- tukey_result_1$statistics

# Access the "parameters" component
parameters <- tukey_result_1$parameters

# Access the "means" component
means <- tukey_result_1$means

# Access the "groups" component
groups <- tukey_result_1$groups

print(tukey_result_1)
#print(groups)
#print(statistics)

```


***

These are the results of the post hoc analysis, specifically the tukey test. The most important part is the comparison value, this returns NULL, meaning that there is no significant difference between any faculty in terms of energy

### Post hoc results valence

```{r statistcal_analysis_valence}

#final_data %>%
  #group_by(faculty) %>%
  #select(valence, energy, faculty, bachelor) %>%
  #summarize(mean_valence = mean(valence), mean_energy = mean(energy), sd_valence = sd(valence), sd_energy = sd(energy))

anova_result_2 <- aov(valence ~ faculty, data = final_data)

#summary(anova_result_1)
#summary(anova_result_2)

#tukey_result_1 <- HSD.test(anova_result_1, "faculty", group = TRUE) #energy
tukey_result_1 <- HSD.test(anova_result_2, "faculty", group = TRUE) #valence

# Access the "statistics" component
statistics <- tukey_result_1$statistics

# Access the "parameters" component
parameters <- tukey_result_1$parameters

# Access the "means" component
means <- tukey_result_1$means

# Access the "groups" component
groups <- tukey_result_1$groups

print(tukey_result_1)
#print(groups)
#print(statistics)

```


***

These are the results of the post hoc analysis, specifically the tukey test. The most important part is the comparison value, this returns NULL, meaning that there is no significant difference between any faculty in terms of valence.

### Post hoc results loudness

```{r statistcal_analysis_loudness}

#final_data %>%
  #group_by(faculty) %>%
  #select(valence, energy, faculty, bachelor) %>%
  #summarize(mean_valence = mean(valence), mean_energy = mean(energy), sd_valence = sd(valence), sd_energy = sd(energy))

anova_result_3 <- aov(loudness ~ faculty, data = final_data)

#summary(anova_result_1)
#summary(anova_result_2)

#tukey_result_1 <- HSD.test(anova_result_1, "faculty", group = TRUE) #energy
tukey_result_3 <- HSD.test(anova_result_3, "faculty", group = TRUE) #valence

# Access the "statistics" component
statistics <- tukey_result_3$statistics

# Access the "parameters" component
parameters <- tukey_result_3$parameters

# Access the "means" component
means <- tukey_result_3$means

# Access the "groups" component
groups <- tukey_result_3$groups

print(tukey_result_3)
#print(groups)
#print(statistics)

```


***

These are the results of the post hoc analysis, specifically the tukey test. The most important part is the comparison value, this returns NULL, meaning that there is no significant difference between any faculty in terms of loudness.


Discussion/Conclusion
=======================================================================

I did a few statistical analyses on the data of my corpus. I specifically looked at energy, valence and loudness. Neither of these variables seemed to have any significant difference between any group as shown in the results of the post hoc analysis (the tukey test). Which means that although the difference are cleary there between groups and songs, there are not any significant differences on average. This is quite interesting because I really thought there would be a significant difference before I started to gather data, however the second I made my first graph I noticed that the differences are not that big on average. This might be because of the small sample sizes and because on average certain genres are more popular then others, which means that there is a big chance that people are fan of the same genre, thus making it more likely to have similar songs in terms of energy, valence and loudness.

I did however learn that tempo analysis and novelty graphs can give a lot of information and insights on a song, and make a lot of sense if you match them to a certain genre (like I mentioned in the corresponding tabs). The chromagram, key and chord analyses made a lot of sense in combination with the type of song (minor or major mainly) which justifies the spotify api which is nice to know that it does things well.

Row  {.tabset}
-----------------------------------------------------------------------
